
#include"CommonHeader.h"
#include"Node.h"

typedef struct TREE_P TREE;
typedef struct TreeDataPointersP TreeDataPointers;
typedef enum MOD_TYPE_P MOD_TYPE;
typedef enum FIND_BY_P FIND_BY;

TREE* newBinaryTree(TreeDataPointers* treeDataPointers, FunctionPointers* nodeFunctionPointers);

int initTree(TREE* tree, FunctionPointers* functionPointers, TreeDataPointers* treeDataPointers);
int deleteTree(TREE* tree);
int saveTree(TREE* tree);

int newElement(TREE* tree, FILE* file);
int addElement(TREE* tree, NODE* nodeIn, int balanceRun);
int balanceTree(TREE* tree, NODE** node);

NODE* modifyElement(TREE* tree, MOD_TYPE modType);

int measureElement(TREE* tree, NODE* node);

int getElementP(TREE* tree, NODE*** ptr_branch);
NODE** getElement(NODE** ptr_branch, FIND_BY type, void* value);

int getIndexIn(void);

int printEntry(TREE* tree);

int printTree(TREE* tree, FIND_BY type, void* target);
int printElement(NODE* node, FIND_BY type, void* target);
int createTitleString(TREE* tree, FIND_BY type, char titleString[]);

/*
  MOD_TYPE
  description
    used by the modify function. Holds a value determining whether the 
    user wishes to modify or remove an element.
  data:
    MODIFY      the user wishes to use the modify function to actually modify
                an element.
    REMOVE      the user wishes to completely remove an element.

*/
enum MOD_TYPE_P 
{ 
  MODIFY = 0 , 
  REMOVE = 1 
};

/*
  FIND_BY
  description
    this enumeration primarally applies to the getElement function.
    the values which it represents indicate by what means data is to be
    located. In the event that this value is generated by function 
    based on user input from a value function it may hold other data
    but only the following are relevent to operations from the
    linked tree's perspective.
  data:
    BY_KEY      this indicates that the comparison which is
                required to find the element required is ordinal, and
                thus requires the calling of an appropriate function
                provided by the value.
    INDEX       an element is to be located by index.

    *OTHER*     other values can be held by this data-type but are processed
                by functions provided elseware.
                

*/
enum FIND_BY_P 
{ 
  BY_KEY  = 0 , 
  INDEX   = 1
};
/*
  TREE
  description
    struct containing the definition for a tree (essentially an abstract structure).
  data:
    root          pointer to a root or "head" node struct 
                  (as defined in Node.h).
    size          the number of elements "size" in the tree.
    staticIndex   the index determining what index value should be 
                  given to the next node added.
    functionPointers   
                  a pointer to a FunctionPointers struct
                  (as defined in Node.h). A reference to this
                  is passed on to all child nodes.
    treeDataPointers   
                  a pointer to a treeDataPointers struct.
                  This contains functions essential to TREE
                  operations and a link to a file where initial
                  data can be found.
*/
struct TREE_P
{
  NODE* root;
  int size;
  int staticIndex;
  FunctionPointers* functionPointers;
  TreeDataPointers* treeDataPointers;
};

/*
  TreeDataPointers
  description
    struct containing the function pointers and
    data neccessary to perform operations on trees.
  data:
    findMenu    menu inquiring as to how the user wishes
                to locate an element.
                  param   -void
                  return  -menu selection
    prompt      obtains input from the user for testing
                purposes.
                  param   -type of value to be obtained
                          -buffer to store input
                  return  -NULL
    tableHeader writes a table header for the "display 
                all" table.
                  param   -buffer to be filled with header
                  return  -NULL

    fileAddress the addres of the file where initial data 
                can be found.
*/
struct TreeDataPointersP 
{
  int (*findMenu)();
  int (*prompt)(int type, void* input);
  int (*tableHeader)(char* string);
  char* fileAddress;
};




/*
  newBinaryTree
  description
    creates a new tree.
  params:
    treeDataPointers
              function pointers and data being 
              associated with the new tree.
    functionPointers
              function pointers being 
              associated with the new node.
  return: 
    TREE*     tree created 
*/
TREE* newBinaryTree(TreeDataPointers* treeDataPointers, FunctionPointers* nodeFunctionPointers)
{

  TREE* tree = (TREE*) malloc(sizeof(TREE));

  if(tree == NULL)
  {
    printf("sufficient memory could not be allocated to create tree");
    PAUSE
    exit(0);
  }
  tree->staticIndex = 0;
  initTree(tree, nodeFunctionPointers, treeDataPointers);
  return tree;
}

/*
  initTree
  description
    creates a new tree.
  params:
    tree      newly created tree to be initialized

    functionPointers
              function pointers being associated
              with the new nodes in the new tree.
    treeDataPointers
              function pointers and data being 
              associated with the new tree.
  return: 
    NULL      0 value indicating successful exicution.
*/
int initTree(TREE* tree, FunctionPointers* functionPointers, TreeDataPointers* treeDataPointers)
{
  FILE* file;
  tree->root = NULL;
  tree->size = 0;
  
  tree->functionPointers = functionPointers;
  tree->treeDataPointers = treeDataPointers;

  file = fopen(tree->treeDataPointers->fileAddress, "rb");
  while(file != NULL && !feof(file))
  {
    newElement(tree, file);
  }
  if(file != NULL)
  {
    fclose(file);
  }
  return 0;
}

/*
  deleteTree
  description
    frees memory assiciated with all structures 
    in a tree.
  params:
    tree      tree to be deleted.
  return: 
    NULL      0 value indicating successful exicution.
*/
int deleteTree(TREE* tree)
{
  NODE* node = tree->root;
  deleteNode(tree->root, 1);


  free(tree);

  return 0;
}

/*
  saveTree
  description
    opens the file, the address of which is provided
    in the treeDataPointers struct, and uses the
    saveNode function to write all associated values
    to it in a binary format.
  params:
    tree      tree to be saved.
  return: 
    NULL      0 value indicating successful exicution.
*/
int saveTree(TREE* tree)
{
  FILE* file = fopen(tree->treeDataPointers->fileAddress, "wb");
  saveNode(tree->root, file);
  fclose(file);
  return 0;
}

/*
  newElement
  description
    in the even that the file variable is not NULL, reads
    the next entry in the file as a node value and adds
    the node to the list. If file is NULL, user is prompted
    for value info.
  params:
    tree      tree to be added to.
    file      from which a new element is to be retrieved.
              When file is NULL the user is prompted for
              contact info.
  return: 
    NULL      0 value indicating successful exicution.
*/
int newElement(TREE* tree, FILE* file)
{
  NODE* node = newNode(tree->functionPointers, &tree->staticIndex, file);
  if(node != NULL)
  {
    addElement(tree, node, 0);
    return 1;
  }
  else
  {
    return 0;
  }
}

/*
  addElement
  description
    adds a new node to the tree.
  params:
    tree      tree to be added to.
    nodeIn    node to be added to the tree.
  return: 
    NULL      0 value indicating successful exicution.
*/
int addElement(TREE* tree, NODE* nodeIn, int balanceRun)
{
  //node array which will hold the inputs new parent and child
  NODE **ptr_branch = &(tree->root), **ptr_root = &(tree->root);

  tree->size++;
  ptr_branch = getElement(ptr_branch, BY_KEY, nodeIn);

  *ptr_branch = nodeIn;
  if(!balanceRun) 
  balanceTree(tree, ptr_root);
  measureElement(tree, tree->root);
  
  return 0;
  
}

/*
  modifyElement
  description
    function is used to modify or delete an element.
  params:
    tree      tree to be modified.
    remove    whether this opereration is to remove (delete)
              an element or not.
  return: 
    node      the modified (or removed) node.
*/
NODE* modifyElement(TREE* tree, MOD_TYPE modType)
{
  //node array which will hold the inputs desired element and its
  //parent
  NODE** ptr_branch = &(tree->root);

  int choice = getElementP(tree, &ptr_branch);

  if(ptr_branch == NULL)
  {
    printf("\nERROR: INPUT NOT FOUND\n");
  }
  else if(choice != 0)
  {
    NODE* node = (*ptr_branch);
    NODE* temp;


    tree->size--;
    if((*ptr_branch)->greater != NULL)
    {

      *ptr_branch = (*ptr_branch)->greater;
      temp = (*ptr_branch);
      while(temp->less != NULL) temp = temp->less;
      temp->less = node->less;
    }
    else if((*ptr_branch)->less != NULL)
    {
      *ptr_branch = (*ptr_branch)->greater;
      temp = (*ptr_branch);
    }
    else *ptr_branch = NULL;


    if(modType == REMOVE)
    {
      deleteNode(node, 0);
      node = NULL;
    }
    else
    {
      //node->index = 0;
      node->greater = NULL;
      node->less = NULL;
      editNode(node);
      addElement(tree, node, 0);
    }
    measureElement(tree, tree->root);
    balanceTree(tree, &tree->root);
    return node;
  }
  else if(choice != 0)
  {
    printf("\nERROR: INPUT NOT FOUND\n");
    
  }
  return NULL;
}


/*
  balanceTree
  description
    function is used to balance a tree and optimize addition, 
    removal, and search processes.
  params:
    tree      tree to be balanced.
    node      whether this opereration is to remove (delete)
              an element or not.
  return: 
    return    the number of changes made to the tree.
*/
int balanceTree(TREE* tree, NODE** node)
{
  NODE *less, *greater, *self;
  int lessH, greaterH;
  int changedNode = 0, changedBranch = 0;
  

  measureElement(tree, tree->root);
  while(node != NULL && *node != NULL)
  {
    
    
    self = *node;
    changedNode++;

    less = self->less;
    greater = self->greater;
    lessH = less ? less->height : 0;
    greaterH = greater ? greater->height : 0;
    if(lessH > greaterH + 1)
    {
      *node = less;
      self->less = NULL;
      addElement(tree, self, 1);
    }
    else if(greaterH > lessH + 1)
    {
      *node = greater;
      self->greater = NULL;
      addElement(tree, self, 1);
    }
    else break;
    

  }
  if(changedNode )
  {
    NODE **branch[] = {&(*node)->less, &(*node)->greater};

    changedBranch += *branch[0] ? balanceTree(tree, branch[0]) : 0;

    changedBranch += *branch[1] ? balanceTree(tree, branch[1]) : 0;
  }
  if(changedBranch) balanceTree(tree, node);


  return changedNode>1 || changedBranch;
}

/*
  measureElement
  description
    updates the numbering on all tree elements.
  params:
    tree      the tree on which the element to be weighed
              exists
    node      node to be weighed.
  return: 
    NULL      0 value indicating successful exicution.
*/
int measureElement(TREE* tree, NODE* node)
{
  
  int left, right;
  if(node == NULL) return 0;
  left = measureElement(tree, node->less);
  right = measureElement(tree, node->greater);

  node->height = left > right ? left : right;
  node->height++;
  return node->height;
}


/*
  getElementP
  description
    function is used to prompt for an element discription, 
    and find sed element.
  params:
    tree      tree to be searched.
    ptr_branch
              nodes are represented as pointers to nodes,
              each node is connected to its children by pointers
              to them, and this parameter is a pointer to one
              such child pointer. the parameter takes the form of
              a triple pointer so that the aforementioned pointer 
              can be changed in this method and such changes will
              be reflected in the calling function.
  return: 
    choice    the type of comparison carried to determine which
              element is desired
*/
int getElementP(TREE* tree, NODE*** ptr_branch)
{

  char* input = valueBufferC;
  FIND_BY choice = (FIND_BY) tree->treeDataPointers->findMenu();
  if(choice != 1 && choice != 0)
  {
    tree->treeDataPointers->prompt(choice, (void*) input);
  }
  else if(choice == 1)
  {
    *((int*) input) = getIndexIn();
  }
  else if(choice == 0)
  {
    input[0] = '\0';
    return NULL;
  }

  *ptr_branch = getElement(*ptr_branch, choice, (void*) input);
  input[0] = '\0';
  return choice;
}

/*
  getElement
  description
    function is used to retrieve an element fitting its parameters.
  params:
    ptr_branch
              the pointer to the pointer connecting the node
              being currently inspected with its parent.
    type      the type of comparison to be carried out.
    value     the value with which nodes are being compared

  return: 
    ptr_branch
              the pointer to the branch referencing the desired
              node.
*/
NODE** getElement(NODE** ptr_branch, FIND_BY type, void* value)
{
  
  int compare;
  NODE** ptr_branch_temp = NULL;
  if(type == BY_KEY) compare = nodeCompareSort(*ptr_branch, ((NODE*) value));
  else if(*ptr_branch != NULL)
  { 
    compare = nodeCompareFind(*ptr_branch, type, value);
  }
  else return NULL;

  if(compare == 0)
  {
    return ptr_branch;
  }

  if(type != BY_KEY || compare > 0)
  {
    ptr_branch_temp = &((*ptr_branch)->less);
    ptr_branch_temp = getElement(ptr_branch_temp, type, value);
	if(ptr_branch_temp) return ptr_branch_temp;
  }

  if(type != BY_KEY || compare < 0)
  {
    ptr_branch_temp = &((*ptr_branch)->greater);
    ptr_branch_temp = getElement(ptr_branch_temp, type, value);
	if(ptr_branch_temp) return ptr_branch_temp;
  }
  return ptr_branch_temp;

}


/*
  getIndexIn
  description
    prompts for and gets the index of the desired element.
  params:
    void
  return: 
    index     the index of the desired element.
*/
int getIndexIn(void)
{
  int index; 
  printf("please enter the index number of the desired contact.");
  scanf("%d", &index);
  return index;
}


/*
  printEntry
  description
    request an element discription from the user then print
    the value's info at full size.
  params:
    tree      tree in which the element is located.
  return: 
    NULL      0 value indicating successful exicution.
*/
int printEntry(TREE* tree)
{
  char* valueString = valueBufferC;


  
  NODE** ptr_branch = &(tree->root);
  int choice = getElementP(tree, &ptr_branch);


  if(ptr_branch != NULL && *ptr_branch != NULL && choice != 0)
  {

    getFunctions(*ptr_branch)->toString(getValue(*ptr_branch), valueString, 1);
    printf("\n%s\n", valueString);

  }
  else if(choice)
  {
    printf("\nERROR: INPUT NOT FOUND\n");
  }
  valueString[0] = '\0';
  return 0;
}


/*
  printTree
  description
    prints formatted tree in tabular form using the criteria provided.
  params:
    tree      tree being printed.
    type      the type of comparison being carried out (if any).
    target    the value being searched for.
  return: 
    NULL      0 value indicating successful exicution.
*/
int printTree(TREE* tree, FIND_BY type, void* target)
{
  char* headString = valueBufferA;
  char* titleString = valueBufferB;

  int i;
  int ws;

  NODE* node = tree->root;
  int count = 0;

  tree->treeDataPointers->tableHeader(headString);
  CLEAR
  
  createTitleString(tree, type, titleString);

  ws = strlen(headString)/2 + 5 - strlen(titleString)/2;
  for(i = 0; i < ws; i++)
  {
    printf(" ");
  }
  printf("%s\n\n", titleString);

  printf("index     %s\n", headString);

  headString[0] = '\0';
  titleString[0] = '\0';

  count = printElement(tree->root, type, target);
  printf((type == BY_KEY ? "%d record(s) fit your description.\n\n" : "you have %d contact(s).\n\n"), count);
  return 0;
}

/*
  printElement
  description
    prints a given element.
  params:
    node      node to be printed.
    type      the type of comparison being carried out (if any).
    target    the value being searched for.
  return: 
    NULL      0 value indicating successful exicution.
*/
int printElement(NODE* node, FIND_BY type, void* target)
{
  char* string = valueBufferA;
  int count = 0;
  if(node == NULL) return 0;

  count += printElement(node->less,type,target);
  
  if(type == BY_KEY || (type != -1 && !nodeCompareFind(node,type,target)) || (type == -1 && (node->greater == NULL && node->less == NULL)))
  {
    string[0] = '\0';
    nodeToString(node, string);
    printf("%s\n", string);
    count++;
  }
  
  
  count+=printElement(node->greater, type, target);
  return count;
}

/*
  createTitleString
  description
    generates a table heading based on the name of the file from which 
    initial records have been read in.
  params:
    tree      tree being printed.
    type      the type of comparison being carried out.
    titleString
              the buffer to which the title is being printed
  return: 
    NULL      0 value indicating successful exicution.
*/
int createTitleString(TREE* tree, FIND_BY type, char titleString[])
{
  int i = 0;
  int titleLength;
  char c[1];
  char* address = tree->treeDataPointers->fileAddress;
  
  titleString[0] = '\0';
  sprintf(titleString, "%s TREE OF ", type == BY_KEY ? "COMPLETE" : "PARTIAL");
  titleLength = strlen(titleString);
  while(address[i] != '.' && address[i] != '\0')
  {
    c[0] = address[i++];
    if(c[0] == '_' || (c[0] > 64 && c[0] < 91))
    {

      titleString[titleLength++] = ' ';

      if(c[0] == '_') continue;
    }
    //capitalizing every char
    titleString[titleLength++] = (c[0] > 96 && c[0] < 123) ? c[0] - 32 : c[0];
  }
  titleString[titleLength++] = '\0';
  return 0;
}